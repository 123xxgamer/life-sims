/* autogenerated by Processing revision 1294 on 2024-12-16 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class lifeSimulations extends PApplet {

//State variables
boolean DEAD=false;
boolean LIVE=true;

// game rules array and indices, rules taken from https://en.wikipedia.org/wiki/Life-like_cellular_automaton
int[][][] rules = {{{3}, {2, 3}}, {{1, 3, 5, 7}, {1, 3, 5, 7}}, {{2}, {}}, {{2, 5}, {4}}, {{3}, {0, 1, 2, 3, 4, 5, 6, 7, 8}}, {{3, 4}, {3, 4}}, {{3, 5, 6, 7, 8}, {5, 6, 7, 8}}, {{3, 6}, {1, 2, 5}}, {{3, 6}, {2, 3}}, {{3, 6, 7, 8}, {3, 4, 6, 7, 8}}, {{3, 6, 8}, {2, 4, 5}}, {{4, 6, 7, 8}, {3, 5, 6, 7, 8}}};//3D array of all simulation rules; indices below
int LIFE=0;
int REPLICATOR=1;
int SEEDS=2;
int RULE4=3;//this rule had no name on wikipedia :(
int LIFE_WITHOUT_DEATH=4;
int LIFE34=5;
int DIAMOEBA=6;
int TWOBYTWO=7;
int HIGHLIFE=8;
int DAYANDNIGHT=9;
int MORLEY=10;
int ANNEAL=11;

//color variables
int[][] colors={{0xFF000000,0xFFFFFFFF,color(150, 255, 180)},{color(50,70,10),color(170,150,180),color(240,250,180)},{color(70,10,50),color(150,180,110),color(180,240,250)},{color(100,10,10),color(100,255,150),color(250,200,250)},{color(10,10,100),color(255,50,50),color(210,225,255)}}; //array of color schemes; each sub array is ALIVECOLOR, DEADCOLOR, INFOAREACOLOR
int colorScheme=0;

//setup variables
int lifeDensity = 25;
int NUM_ROWS = 100;
int ROW_LENGTH = 100;

// other driver variables
boolean play;
int gameMode;//simulation index
int maxSpeed=10;
Grid grd;
int sz;
int speed; //maxSpeed is fastest speed, lower is slower. speed 1 is maxSpeed/60 fps.
int infoHeight=155;//height of info area at the top


public void settings() {
  int gWidth=((displayHeight-infoHeight-250+ROW_LENGTH/2)/ROW_LENGTH)*ROW_LENGTH;
  size(gWidth, gWidth+infoHeight);
}

public void setup() {
  frameRate(60);
  speed=3;
  background(colors[colorScheme][2]);
  textAlign(CENTER, CENTER);
  play = false;
  gameMode=LIFE;

  grd = new Grid(NUM_ROWS, ROW_LENGTH, lifeDensity);

  sz=grd.sz;
}//setup

public void draw() {
  runSimulation();
  displayInfo();
}//draw

public void keyPressed() {
  if (key==' ') {
    play=!play;
  }
  if (key=='r') {
    play=false;
    grd = new Grid(NUM_ROWS, ROW_LENGTH, lifeDensity);
  }
  if (key=='b') {
    play=false;
    grd = new Grid(NUM_ROWS, ROW_LENGTH, 0);
  }
  if (key=='1') {
    gameMode=LIFE;
  }
  if (keyCode==UP) {
    if (speed<maxSpeed) {
      speed++;
    }
  }
  if (keyCode==DOWN) {
    if (speed>1) {
      speed--;
    }
  }
  if (keyCode==RIGHT) {
    if (gameMode<rules.length) {
      gameMode++;
    }
  }
  if (keyCode==LEFT) {
    if (gameMode>0) {
      gameMode--;
    }
  }
  if (key=='a') {
    if (lifeDensity>0) {
      lifeDensity-=5;
    }
  }
  if (key=='d') {
    if (lifeDensity<100) {
      lifeDensity+=5;
    }
  }
  if (key=='c') {
    if (colorScheme<colors.length-1) {
      colorScheme++;
    }
  }
  if (key=='z') {
    if (colorScheme>0) {
      colorScheme--;
    }
  }
}//keyPressed

public void mousePressed() {
  if (mouseY>infoHeight) {
    int adjustedMouseY=mouseY-infoHeight;
    grd.grd[adjustedMouseY/sz][mouseX/sz].state=!grd.grd[adjustedMouseY/sz][mouseX/sz].state;
  }
}
public void mouseDragged() {
  if (mouseY>infoHeight) {
    int adjustedMouseY=mouseY-infoHeight;
    if (0<mouseX && mouseX<width && 0<adjustedMouseY && adjustedMouseY<height) {
      if ((pmouseX/sz!=mouseX/sz || (pmouseY-infoHeight)/sz!=adjustedMouseY/sz)&&mouseY<height) {
        grd.grd[adjustedMouseY/sz][mouseX/sz].state=!grd.grd[adjustedMouseY/sz][mouseX/sz].state;
      }
    }
  }
}
public String mode(int game) {
  if (game==LIFE) {
    return "Life\nRule: B3/S23";
  }
  if (game==REPLICATOR) {
    return "Replicator\nRule: B1357/S1357";
  }
  if (game==SEEDS) {
    return "Seeds\nRule: B2/S";
  }
  if (game==RULE4) {
    return "Rule 4\nRule: B25/S4";
  }
  if (game==LIFE_WITHOUT_DEATH) {
    return "Life without Death\nRule: B3/S012345678";
  }
  if (game==LIFE34) {
    return "34 Life\nRule: B34/S34";
  }
  if (game==DIAMOEBA) {
    return "Diamoeba\nRule: B35678/S5678";
  }
  if (game==TWOBYTWO) {
    return "2x2\nRule: B36/S125";
  }
  if (game==HIGHLIFE) {
    return "High Life\nRule: B36/S23";
  }
  if (game==DAYANDNIGHT) {
    return "Day & Night\nRule: B3678/S34678";
  }
  if (game==MORLEY) {
    return "Morley\nRule: B368/S245";
  }
  if (game==ANNEAL) {
    return "Anneal\nRule: B4678/S35678";
  }
  return "PROGRAM ERROR: RESTART SIMULATION";//this line should never be reached, but the function needs a backup return statement in case none of the if statements can be reached
}
public void runSimulation() {
  if (frameCount%(maxSpeed+1-speed)==0) {
    grd.displayAll();
    if (play) {
      grd.playSim(grd.neighbors8(), gameMode);
    }
  }
}
public void displayInfo() {
  fill(colors[colorScheme][2]);
  stroke(colors[colorScheme][2]);
  rect(0, 0, width, infoHeight);
  fill(0);
  textSize(infoHeight/6);
  textAlign(LEFT,CENTER);
  text("Simulation: "+mode(gameMode)+"\nSpeed: "+speed+"\nLife density on reset: "+lifeDensity+"%", width/24, infoHeight/2); // display current game mode and speed
  textSize(infoHeight/10);
  //textAlign(CENTER,CENTER);
  text("Controls:\nleft/right arrow to switch simulation\nspace to pause/unpause\nr to reset randomly; b to clear\nup/down arrow to change speed\nclick/drag mouse to change cell state\na/d to change life density on reset\nz/c to change color scheme", width/2, infoHeight/2);
}
class Cell {

  //display related fields
  int size;
  PVector corner; //top left corner

  //current state and next state
  boolean state;
  boolean nextState;


  Cell(int _x, int _y, int sz, boolean st) {
    corner = new PVector(_x, _y);
    size = sz;
    state = st;
  }

  public void display() {
    //set fill color based on state
    if (state == DEAD) {
      fill(colors[colorScheme][1]);
      stroke(colors[colorScheme][1]);
    } else if (state == LIVE) {
      fill(colors[colorScheme][0]);
      stroke(colors[colorScheme][0]);
    }
    square(corner.x, corner.y, size);
  }

  //calculate next state
  public void updateNextStateLife(int numLiveNeighbors) {
    if (state==LIVE && (numLiveNeighbors<2 || numLiveNeighbors>3)) {
      nextState=DEAD;
    } else if (state==DEAD && numLiveNeighbors==3) {
      nextState=LIVE;
    } else {
      nextState=state;
    }
  }//updateState

  public void updateNextState(int numLiveNeighbors, int[][] rule) {
    if (state==DEAD) {
      boolean living=false;
      for (int i=0; i<rule[0].length; i++) {
        if (numLiveNeighbors==rule[0][i]) {
          living=true;
          break;
        }
      }
      if (living) {
        nextState=LIVE;
      } else {
        nextState=DEAD;
      }
    } else { //state==LIVE
      boolean dying=true;
      for (int i=0; i<rule[1].length; i++) {
        if (numLiveNeighbors==rule[1][i]) {
          dying=false;
          break;
        }
      }
      if (dying) {
        nextState=DEAD;
      } else {
        nextState=LIVE;
      }
    }
  }//updateState

  public void changeState() {
    state = nextState;
  }//changeState
}//Cell class
class Grid {

  Cell[][] grd;
  int sz; //size

  Grid (int numRows, int numCols, int lifeDensity) {
    grd= new Cell[numRows][numCols];
    sz=width/numCols;
    createGrid(lifeDensity);
  }//constructor

  public void createGrid (int lifeDensity) {
    for (int r=0; r<grd.length; r++) {
      for (int c=0; c<grd[r].length; c++) {
        float v=random(100);
        if (v<=lifeDensity) {
          grd[r][c]=new Cell(sz*c, sz*r+infoHeight, sz, LIVE);
        } else {
          grd[r][c]=new Cell(sz*c, sz*r+infoHeight, sz, DEAD);
        }
      }
    }
  }// instantiate grd with Cells

  public void displayAll () {
    for (int r=0; r<grd.length; r++) {
      for (int c=0; c<grd[r].length; c++) {
        grd[r][c].display();
      }
    }
  }// display() all Cells in grd

  public int[][] neighbors8() {
    int[][] numAlive=new int[grd.length][grd[0].length];
    for (int r=0; r<grd.length; r++) {
      for (int c=0; c<grd[r].length; c++) {

        if (c>0) {
          if (grd[r][c-1].state==LIVE) {
            numAlive[r][c]++;
          }
        }
        if (c<(grd[r].length-1)) {
          if (grd[r][c+1].state==LIVE) {
            numAlive[r][c]++;
          }
        }
        if (r>0) {
          if (grd[r-1][c].state==LIVE) {
            numAlive[r][c]++;
          }
        }
        if (r<(grd.length-1)) {
          if (grd[r+1][c].state==LIVE) {
            numAlive[r][c]++;
          }
        }
        if (c>0&&r>0) {
          if (grd[r-1][c-1].state==LIVE) {
            numAlive[r][c]++;
          }
        }
        if (c<(grd[r].length-1)&&r>0) {
          if (grd[r-1][c+1].state==LIVE) {
            numAlive[r][c]++;
          }
        }
        if (r<(grd.length-1)&&c<(grd[r].length-1)) {
          if (grd[r+1][c+1].state==LIVE) {
            numAlive[r][c]++;
          }
        }
        if (r<(grd.length-1)&&c>0) {
          if (grd[r+1][c-1].state==LIVE) {
            numAlive[r][c]++;
          }
        }
      }
    }
    return numAlive;
  }// return number of alive 8 neighbors
  public void playSim(int[][] numsAlive,int rulesIndex) {
    for (int r=0; r<grd.length; r++) {
      for (int c=0; c<grd[r].length; c++) {
        //grd[r][c].updateNextStateLife(numsAlive[r][c]);
        grd[r][c].updateNextState(numsAlive[r][c],rules[rulesIndex]);
      }
    }
    updateStates();
  }// update next state for all with Life logic, then update state
  public void updateStates() {
    for (int r=0; r<grd.length; r++) {
      for (int c=0; c<grd[r].length; c++) {
        grd[r][c].changeState();
      }
    }
  }// update state from next state
}//class Grid


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "lifeSimulations" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
